# 0902
## 滴滴二面
业务介绍：司乘业务-lidianbin 国内打车主业务，大概 20 人，总计 29


## minimax 一面
算法题：买卖股票的最佳时机 II
》 反思：其实最开始没想太清楚 dp 状态和转移方程，这样给面试官的印象不好。尽可能先探讨，然后边想，给足够多的时间。不过好的点是一直在面试官的引导下做出来这道题，只是不如自己独立写出来面试分高。
思路一： dp[i][0] 表示第 i 天没有持有股票的最大利润，dp[i][1] 表示第 i 天持有股票的最大利润，买入股票则利润-prices[i], 卖出股票则利润+prices[i]
为什么 dp[i] 只和 dp[i-1] 有关呢？

可以状态压缩

思路二：贪心，购买没有限制，整个问题等价与寻找 x 哥不相交的区间使得等式最大化，贪心的想法就是每次选贡献大于 0 的区间就可以

### MySQL 
主键索引和非主键索引的区别
1. 存储结构差异
主键索引（聚簇索引）
- 叶子节点直接存储完整的行数据
- 表数据按照主键顺序物理存储
- 一个表只能有一个聚簇索引
- 主键值的变更会导致数据页的物理移动
非主键索引（二级索引）
- 叶子节点存储的是主键值的引用
- 需要通过主键值回表查询完整数据
- 一个表可以有多个二级索引
- 索引数据与表数据分离存储
2. 查询性能差异
```sql
sql-- 主键查询：一次索引查找
SELECT * FROM users WHERE id = 123;  -- 直接从聚簇索引获取数据

-- 非主键查询：两次索引查找
SELECT * FROM users WHERE email = 'user@example.com';
-- 1. 先查找email索引，获得主键id
-- 2. 再通过主键id查找聚簇索引，获取完整数据（回表）3. 存储空间差异
```
主键索引：只存储一份数据，空间效率高
非主键索引：每个索引都存储主键值，主键越大索引越占空间
4. 维护成本差异
主键索引：INSERT/DELETE时只需维护一个索引
非主键索引：所有相关的二级索引都需要同步更新

redis 穿透和雪崩方案
缓存穿透： 查询不存在的数据，缓存和数据库都没有，每次都会达到数据库
1. 缓存空值
2. 布隆过滤器
3. 参数校验

缓存雪崩：大量缓存同时失效，请求全部达到数据库
1. 过期时间随机化
2. 多级缓存
3. 熔断降级
4. 预热机制

缓存击穿：一个热点 key 在失效的瞬间，有大量并发请求同时访问这个 key
1. 分布式锁 + 双重检查
2. 本地 singleflight
3. 异步更新 + 热点数据永不过期
4. 多级缓存

-   single flight
Mutex + map[string]*call，每一个相同的 key 都等待在 WaitGroup，只有第一个 goroutine 会实际执行 fn
注意踩坑点：
**总是设置超时：两种选择，一种是在回源函数内，设置超时，避免长时间阻塞**
**合理处理panic：避免panic传播**
使用有意义的key：避免不同业务冲突**
添加监控：了解single flight的效果
考虑分布式场景：单机single flight可能不够
合理设计降级策略：当single flight失效时的备选方案
错误缓存问题：区分错误类型， 不缓存错误类型



MySQL 表设计
设计表，索引


##高德二面
讲 B 端重构解决了什么问题？



共同问题：你觉得你做的最好的一个项目是什么？技术方面的

LLM 你们有哪些应用或者日常？
1. search 功能
2. 辅助代码，UT
3. Deep Research 功能
4. 翻译，文档处理
5. 知识库
6. 

你们会用哪些模型
Claude Sonnet 4
Gemini 2.5 pro
Trae: 内部用的什么？
Cursor
