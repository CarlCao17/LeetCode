
算法题 删除有序链表中的重复节点
1->2->2->3->3->4
```go
package main

import (
	"fmt"
	"strings"
)
type ListNode struct {
	Val int
	Next *ListNode
  }

  func (l *ListNode) String() string {
	var sb strings.Builder
	sb.WriteString("[")
	for p := l; p != nil; p = p.Next {
		if p != l {
			sb.WriteString(",")
		}
		sb.WriteString(fmt.Sprint(p.Val))
	}
	sb.WriteString("]")
	return sb.String()
  }
  
  func DelDupNode(root *ListNode) *ListNode {
	if root == nil {
	  return nil
	}
	dummy := &ListNode{
	  Next: root,
	}
	pre := dummy
	
	var next *ListNode
	p := pre.Next
  
	for p != nil {
	  for next = p.Next; next != nil && next.Val == p.Val; next = next.Next {}
	  if p.Next == next {
		pre = p
		p = next
	  } else {
		p = next
		pre.Next = p
	  }
	}
	return dummy.Next
  }
  
  func main() {
	list := toList([]int{1,2,2,3,3,4}) 
	expect := toList([]int{1,4})
	got := DelDupNode(list)
	if !ListMatch(got, expect) {
	  fmt.Printf("1: got=%s, expect=%s", got.String(), expect.String())
	  return 
	}
	
	list = toList([]int{0})
	expect = toList([]int{0})
	got = DelDupNode(list)
	 if !ListMatch(got, expect) {
	  fmt.Printf("2: got=%s, expect=%s", got.String(), expect.String())
	  return 
	}
  
	list = toList([]int{1,2,3,4,5})
	expect = toList([]int{1,2,3,4,5})
	got = DelDupNode(list)
	 if !ListMatch(got, expect) {
	  fmt.Printf("3: got=%s, expect=%s", got.String(), expect.String())
	}
    // 还有一些边界 Case: 1,1,2,2,3; 1,2,2,2; 2,2,2,2
  }
  
  func toList(nums []int) *ListNode {
	if len(nums) == 0 {
	  return nil
	}
	dummy := &ListNode{}
	pre := dummy
	for _, n := range nums {
	  pre.Next = &ListNode{Val: n}
	  pre = pre.Next
	}
	return dummy.Next
  }
  
  func ListMatch(a, b *ListNode) bool {
	if a == b {
	  return true
	}
	if a == nil && b != nil || (a != nil && b == nil) {
	  return false
	}
	if a.Val != b.Val {
	  return false
	}
	return ListMatch(a.Next, b.Next)
  }
  
```

建设 AB 实验平台
背景：AB 数据驱动
为什么需要自己做呢：下钻到落地页维度，为落地页定制一些常见的实验类型，通过配置化快速开启实验
做了哪些事情：
    - 在 Libra AB 参数分流基础上，继续增加落地页粒度的过滤（哪些流量命中了我们的实验），命中了哪个组直接复用
    - 一个流量会命中多个流量，打标回传真实过滤的实验命中结果，不会改变 AB 分组的结果
        》 流量漏斗：
        重新生成报表：Bingo 打标，返回 Array，给用户

    - 我担任的角色：项目的发起，PoC 是我

AB 实验平台
> 一句话描述 AB 实验平台的整体架构

API 分流服务
Libra 实验平台管理流量层，新增实验，实验的流量组
    - 复用一个流量层，或者创建一个新流量层
        - 流量层维护一个正在开的实验的流量分配关系：决定了这个流量层
    - 在这个流量层下占用一部分流量创建一个实验
    - 这个实验分成两个组，对照组和实验组，分别占有一定比例流量

报表

   - 分流服务保证用户随机、均匀地进入到不同实验、不同实验组（两次哈希）
    - 采用`Murmur` 哈希算法，保证均匀分布到输出空间
        - 数据分块 -> 乘法混合，打乱比特位 -> 位旋转 -> XOR 操作，混合信息
        - 高性能，低碰撞率，均匀
    - 流量分桶：`hash("${id}_${layer_name}") % 1000`
    - 用户分组：`hash("${id}:${flight_name}")% ${version_number}`
   - 支持流量大规模复用，保证多个实验能够并行不互相干扰：流量层同层互斥，层间正交
   - 保证实验分组稳定
   |![alt text](image.png) |![alt text](image-1.png)|
   
具体机理
![alt text](image-2.png)

Bingo 标签
给
收益是什么

